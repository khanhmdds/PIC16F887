CCS PCM C Compiler, Version 5.015, 5967               20-Jul-21 13:59

               Filename:   C:\Users\ADMIN\Desktop\PROJECT_PIC\main.lst

               ROM used:   691 words (8%)
                           Largest free fragment is 2048
               RAM used:   20 (5%) at main() level
                           32 (9%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   1E7
0003:  NOP
.................... #include <main.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0004:  DATA D2,22
0005:  DATA 44,10
0006:  DATA CC,24
0007:  DATA 47,24
0008:  DATA 54,10
0009:  DATA 20,10
000A:  DATA 00,00
000B:  DATA 53,2A
000C:  DATA 4F,28
000D:  DATA A0,10
000E:  DATA A1,10
000F:  DATA 20,10
0010:  DATA 20,00
0011:  DATA 47,29
0012:  DATA C5,22
0013:  DATA 4E,10
0014:  DATA CC,24
0015:  DATA 47,24
0016:  DATA 54,10
0017:  DATA 20,00
0018:  DATA C7,27
0019:  DATA A0,20
001A:  DATA C8,22
001B:  DATA 41,22
001C:  DATA 20,10
001D:  DATA 00,01
001E:  DATA D9,22
001F:  DATA 4C,26
0020:  DATA CF,2B
0021:  DATA 20,26
0022:  DATA C9,23
0023:  DATA 48,2A
0024:  DATA 00,01
0025:  DATA 53,26
0026:  DATA CF,2B
0027:  DATA 20,22
0028:  DATA CF,2B
0029:  DATA 4E,00
*
011F:  MOVF   0B,W
0120:  MOVWF  2E
0121:  BCF    0B.7
0122:  BSF    03.5
0123:  BSF    03.6
0124:  BSF    0C.7
0125:  BSF    0C.0
0126:  NOP
0127:  NOP
0128:  BCF    03.5
0129:  BCF    03.6
012A:  BTFSC  2E.7
012B:  BSF    0B.7
012C:  BSF    03.6
012D:  MOVF   0C,W
012E:  ANDLW  7F
012F:  BTFSC  03.2
0130:  GOTO   173
0131:  BCF    03.6
0132:  MOVWF  2E
0133:  BSF    03.6
0134:  MOVF   0D,W
0135:  BCF    03.6
0136:  MOVWF  2F
0137:  BSF    03.6
0138:  MOVF   0F,W
0139:  BCF    03.6
013A:  MOVWF  30
013B:  MOVF   2E,W
013C:  MOVWF  31
013D:  CALL   0F3
013E:  MOVF   2F,W
013F:  BSF    03.6
0140:  MOVWF  0D
0141:  BCF    03.6
0142:  MOVF   30,W
0143:  BSF    03.6
0144:  MOVWF  0F
0145:  BCF    03.6
0146:  MOVF   0B,W
0147:  MOVWF  31
0148:  BCF    0B.7
0149:  BSF    03.5
014A:  BSF    03.6
014B:  BSF    0C.7
014C:  BSF    0C.0
014D:  NOP
014E:  NOP
014F:  BCF    03.5
0150:  BCF    03.6
0151:  BTFSC  31.7
0152:  BSF    0B.7
0153:  BSF    03.6
0154:  RLF    0C,W
0155:  RLF    0E,W
0156:  ANDLW  7F
0157:  BTFSC  03.2
0158:  GOTO   173
0159:  BCF    03.6
015A:  MOVWF  2E
015B:  BSF    03.6
015C:  MOVF   0D,W
015D:  BCF    03.6
015E:  MOVWF  2F
015F:  BSF    03.6
0160:  MOVF   0F,W
0161:  BCF    03.6
0162:  MOVWF  30
0163:  MOVF   2E,W
0164:  MOVWF  31
0165:  CALL   0F3
0166:  MOVF   2F,W
0167:  BSF    03.6
0168:  MOVWF  0D
0169:  BCF    03.6
016A:  MOVF   30,W
016B:  BSF    03.6
016C:  MOVWF  0F
016D:  INCF   0D,F
016E:  BTFSC  03.2
016F:  INCF   0F,F
0170:  BCF    03.6
0171:  GOTO   11F
0172:  BSF    03.6
0173:  BCF    03.6
0174:  RETURN
0175:  MOVF   2E,W
0176:  XORWF  2F,W
0177:  ANDLW  80
0178:  MOVWF  31
0179:  BTFSS  2E.7
017A:  GOTO   17D
017B:  COMF   2E,F
017C:  INCF   2E,F
017D:  BTFSS  2F.7
017E:  GOTO   181
017F:  COMF   2F,F
0180:  INCF   2F,F
0181:  MOVF   2F,W
0182:  CLRF   78
0183:  SUBWF  2E,W
0184:  BTFSC  03.0
0185:  GOTO   189
0186:  MOVF   2E,W
0187:  MOVWF  77
0188:  GOTO   195
0189:  CLRF   77
018A:  MOVLW  08
018B:  MOVWF  30
018C:  RLF    2E,F
018D:  RLF    77,F
018E:  MOVF   2F,W
018F:  SUBWF  77,W
0190:  BTFSC  03.0
0191:  MOVWF  77
0192:  RLF    78,F
0193:  DECFSZ 30,F
0194:  GOTO   18C
0195:  BTFSS  31.7
0196:  GOTO   199
0197:  COMF   78,F
0198:  INCF   78,F
0199:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000) 
....................  
....................  
.................... #FUSES HS 
.................... #USE DELAY (CLOCK=20M) 
*
002A:  MOVLW  33
002B:  MOVWF  04
002C:  BCF    03.7
002D:  MOVF   00,W
002E:  BTFSC  03.2
002F:  GOTO   03D
0030:  MOVLW  06
0031:  MOVWF  78
0032:  CLRF   77
0033:  DECFSZ 77,F
0034:  GOTO   033
0035:  DECFSZ 78,F
0036:  GOTO   032
0037:  MOVLW  7B
0038:  MOVWF  77
0039:  DECFSZ 77,F
003A:  GOTO   039
003B:  DECFSZ 00,F
003C:  GOTO   030
003D:  RETURN
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
01FC:  BCF    03.6
01FD:  CLRF   20
01FE:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
005B:  MOVLW  0F
005C:  BSF    03.5
005D:  ANDWF  08,W
005E:  IORLW  F0
005F:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0060:  BCF    03.5
0061:  BSF    08.2
....................    delay_cycles(1); 
0062:  NOP
....................    lcd_output_enable(1); 
0063:  BSF    08.0
....................    delay_cycles(1); 
0064:  NOP
....................    high = lcd_read_nibble(); 
0065:  CALL   04F
0066:  MOVF   78,W
0067:  MOVWF  39
....................        
....................    lcd_output_enable(0); 
0068:  BCF    08.0
....................    delay_cycles(1); 
0069:  NOP
....................    lcd_output_enable(1); 
006A:  BSF    08.0
....................    delay_us(1); 
006B:  GOTO   06C
006C:  GOTO   06D
006D:  NOP
....................    low = lcd_read_nibble(); 
006E:  CALL   04F
006F:  MOVF   78,W
0070:  MOVWF  38
....................        
....................    lcd_output_enable(0); 
0071:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0072:  MOVLW  0F
0073:  BSF    03.5
0074:  ANDWF  08,W
0075:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0076:  BCF    03.5
0077:  SWAPF  39,W
0078:  MOVWF  77
0079:  MOVLW  F0
007A:  ANDWF  77,F
007B:  MOVF   77,W
007C:  IORWF  38,W
007D:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
004F:  MOVF   08,W
0050:  MOVWF  77
0051:  SWAPF  08,W
0052:  ANDLW  0F
0053:  MOVWF  78
....................   #endif 
0054:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
003E:  SWAPF  39,W
003F:  ANDLW  F0
0040:  MOVWF  77
0041:  MOVLW  0F
0042:  ANDWF  08,W
0043:  IORWF  77,W
0044:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
0045:  NOP
....................    lcd_output_enable(1); 
0046:  BSF    08.0
....................    delay_us(2); 
0047:  MOVLW  02
0048:  MOVWF  77
0049:  DECFSZ 77,F
004A:  GOTO   049
004B:  GOTO   04C
004C:  NOP
....................    lcd_output_enable(0); 
004D:  BCF    08.0
004E:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0055:  BSF    03.5
0056:  BCF    08.0
....................    lcd_rs_tris(); 
0057:  BCF    08.1
....................    lcd_rw_tris(); 
0058:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0059:  BCF    03.5
005A:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
007E:  MOVF   78,W
007F:  MOVWF  38
0080:  BTFSC  38.7
0081:  GOTO   05B
....................    lcd_output_rs(address); 
0082:  BTFSS  36.0
0083:  BCF    08.1
0084:  BTFSC  36.0
0085:  BSF    08.1
....................    delay_cycles(1); 
0086:  NOP
....................    lcd_output_rw(0); 
0087:  BCF    08.2
....................    delay_cycles(1); 
0088:  NOP
....................    lcd_output_enable(0); 
0089:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
008A:  SWAPF  37,W
008B:  MOVWF  38
008C:  MOVLW  0F
008D:  ANDWF  38,F
008E:  MOVF   38,W
008F:  MOVWF  39
0090:  CALL   03E
....................    lcd_send_nibble(n & 0xf); 
0091:  MOVF   37,W
0092:  ANDLW  0F
0093:  MOVWF  38
0094:  MOVWF  39
0095:  CALL   03E
0096:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0097:  MOVLW  28
0098:  MOVWF  2F
0099:  MOVLW  0C
009A:  MOVWF  30
009B:  MOVLW  01
009C:  MOVWF  31
009D:  MOVLW  06
009E:  MOVWF  32
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
009F:  BCF    08.0
....................    lcd_output_rs(0); 
00A0:  BCF    08.1
....................    lcd_output_rw(0); 
00A1:  BCF    08.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00A2:  MOVLW  0F
00A3:  BSF    03.5
00A4:  ANDWF  08,W
00A5:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
00A6:  BCF    08.0
....................    lcd_rs_tris(); 
00A7:  BCF    08.1
....................    lcd_rw_tris(); 
00A8:  BCF    08.2
....................  #endif 
....................      
....................    delay_ms(15); 
00A9:  MOVLW  0F
00AA:  BCF    03.5
00AB:  MOVWF  33
00AC:  CALL   02A
....................    for(i=1;i<=3;++i) 
00AD:  MOVLW  01
00AE:  MOVWF  2E
00AF:  MOVF   2E,W
00B0:  SUBLW  03
00B1:  BTFSS  03.0
00B2:  GOTO   0BB
....................    { 
....................        lcd_send_nibble(3); 
00B3:  MOVLW  03
00B4:  MOVWF  39
00B5:  CALL   03E
....................        delay_ms(5); 
00B6:  MOVLW  05
00B7:  MOVWF  33
00B8:  CALL   02A
00B9:  INCF   2E,F
00BA:  GOTO   0AF
....................    } 
....................     
....................    lcd_send_nibble(2); 
00BB:  MOVLW  02
00BC:  MOVWF  39
00BD:  CALL   03E
....................    delay_ms(5); 
00BE:  MOVLW  05
00BF:  MOVWF  33
00C0:  CALL   02A
....................    for(i=0;i<=3;++i) 
00C1:  CLRF   2E
00C2:  MOVF   2E,W
00C3:  SUBLW  03
00C4:  BTFSS  03.0
00C5:  GOTO   0D2
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
00C6:  MOVLW  2F
00C7:  ADDWF  2E,W
00C8:  MOVWF  04
00C9:  BCF    03.7
00CA:  MOVF   00,W
00CB:  MOVWF  33
00CC:  CLRF   36
00CD:  MOVF   33,W
00CE:  MOVWF  37
00CF:  CALL   055
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00D0:  INCF   2E,F
00D1:  GOTO   0C2
00D2:  BCF    0A.3
00D3:  BCF    0A.4
00D4:  GOTO   21D (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
00E1:  DECFSZ 33,W
00E2:  GOTO   0E4
00E3:  GOTO   0E7
....................       address=LCD_LINE_TWO; 
00E4:  MOVLW  40
00E5:  MOVWF  34
00E6:  GOTO   0E8
....................    else 
....................       address=0; 
00E7:  CLRF   34
....................       
....................    address+=x-1; 
00E8:  MOVLW  01
00E9:  SUBWF  32,W
00EA:  ADDWF  34,F
....................    lcd_send_byte(0,0x80|address); 
00EB:  MOVF   34,W
00EC:  IORLW  80
00ED:  MOVWF  35
00EE:  CLRF   36
00EF:  MOVF   35,W
00F0:  MOVWF  37
00F1:  CALL   055
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00F2:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
00F3:  MOVF   31,W
00F4:  XORLW  07
00F5:  BTFSC  03.2
00F6:  GOTO   101
00F7:  XORLW  0B
00F8:  BTFSC  03.2
00F9:  GOTO   106
00FA:  XORLW  06
00FB:  BTFSC  03.2
00FC:  GOTO   10E
00FD:  XORLW  02
00FE:  BTFSC  03.2
00FF:  GOTO   114
0100:  GOTO   119
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0101:  MOVLW  01
0102:  MOVWF  32
0103:  MOVWF  33
0104:  CALL   0E1
0105:  GOTO   11E
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0106:  CLRF   36
0107:  MOVLW  01
0108:  MOVWF  37
0109:  CALL   055
....................                      delay_ms(2); 
010A:  MOVLW  02
010B:  MOVWF  33
010C:  CALL   02A
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
010D:  GOTO   11E
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
010E:  MOVLW  01
010F:  MOVWF  32
0110:  MOVLW  02
0111:  MOVWF  33
0112:  CALL   0E1
0113:  GOTO   11E
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0114:  CLRF   36
0115:  MOVLW  10
0116:  MOVWF  37
0117:  CALL   055
0118:  GOTO   11E
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0119:  MOVLW  01
011A:  MOVWF  36
011B:  MOVF   31,W
011C:  MOVWF  37
011D:  CALL   055
....................      #endif 
....................    } 
011E:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #DEFINE SCK PIN_C0 
.................... #DEFINE SER PIN_C1 
.................... #DEFINE RCK PIN_C2 
.................... #DEFINE G PIN_C3 
....................  
.................... #DEFINE D PIN_B0 
.................... #DEFINE X PIN_B1 
.................... #DEFINE V PIN_B2 
....................  
.................... #DEFINE LCD_ENABLE_PIN PIN_D0 
.................... #DEFINE LCD_RS_PIN PIN_D1 
.................... #DEFINE LCD_RW_PIN PIN_D2 
.................... #DEFINE LCD_DATA4 PIN_D4 
.................... #DEFINE LCD_DATA5 PIN_D5 
.................... #DEFINE LCD_DATA6 PIN_D6 
.................... #DEFINE LCD_DATA7 PIN_D7 
....................  
.................... UNSIGNED INT8 MA7DOAN[10] = {0XC0,0XF9,0XA4,0XB0,0X99,0X92,0X82,0XF8,0X80,0X90}; 
*
01FF:  MOVLW  C0
0200:  MOVWF  22
0201:  MOVLW  F9
0202:  MOVWF  23
0203:  MOVLW  A4
0204:  MOVWF  24
0205:  MOVLW  B0
0206:  MOVWF  25
0207:  MOVLW  99
0208:  MOVWF  26
0209:  MOVLW  92
020A:  MOVWF  27
020B:  MOVLW  82
020C:  MOVWF  28
020D:  MOVLW  F8
020E:  MOVWF  29
020F:  MOVLW  80
0210:  MOVWF  2A
0211:  MOVLW  90
0212:  MOVWF  2B
.................... SIGNED INT8 GG; 
....................  
.................... void lcd_refresh() 
.................... { 
.................... lcd_send_byte(1,0); 
*
00D5:  MOVLW  01
00D6:  MOVWF  36
00D7:  CLRF   37
00D8:  CALL   055
.................... lcd_send_byte(1,6); 
00D9:  MOVLW  01
00DA:  MOVWF  36
00DB:  MOVLW  06
00DC:  MOVWF  37
00DD:  CALL   055
00DE:  BCF    0A.3
00DF:  BCF    0A.4
00E0:  GOTO   21E (RETURN)
.................... } 
....................  
.................... VOID XUAT1BYTE(UNSIGNED INT8 BYTEXUAT) 
.................... { 
....................    UNSIGNED INT8 I; 
....................    #BIT BSER = BYTEXUAT.7 
....................    FOR(I=0;I<8;I++) 
*
019A:  CLRF   30
019B:  MOVF   30,W
019C:  SUBLW  07
019D:  BTFSS  03.0
019E:  GOTO   1B9
....................    { 
....................       OUTPUT_BIT(SER,BSER); 
019F:  BTFSC  2F.7
01A0:  GOTO   1A3
01A1:  BCF    07.1
01A2:  GOTO   1A4
01A3:  BSF    07.1
01A4:  BCF    2D.1
01A5:  MOVF   2D,W
01A6:  BSF    03.5
01A7:  MOVWF  07
....................       OUTPUT_LOW(SCK); 
01A8:  BCF    03.5
01A9:  BCF    2D.0
01AA:  MOVF   2D,W
01AB:  BSF    03.5
01AC:  MOVWF  07
01AD:  BCF    03.5
01AE:  BCF    07.0
....................       OUTPUT_HIGH(SCK); 
01AF:  BCF    2D.0
01B0:  MOVF   2D,W
01B1:  BSF    03.5
01B2:  MOVWF  07
01B3:  BCF    03.5
01B4:  BSF    07.0
....................       BYTEXUAT = BYTEXUAT << 1; 
01B5:  BCF    03.0
01B6:  RLF    2F,F
01B7:  INCF   30,F
01B8:  GOTO   19B
....................    } 
01B9:  RETURN
.................... } 
.................... VOID GIAIMA7DOAN() 
.................... { 
....................    XUAT1BYTE(MA7DOAN[GG/10]); 
01BA:  MOVF   2C,W
01BB:  MOVWF  2E
01BC:  MOVLW  0A
01BD:  MOVWF  2F
01BE:  CALL   175
01BF:  MOVLW  22
01C0:  ADDWF  78,W
01C1:  MOVWF  04
01C2:  BCF    03.7
01C3:  MOVF   00,W
01C4:  MOVWF  2E
01C5:  MOVWF  2F
01C6:  CALL   19A
....................    XUAT1BYTE(MA7DOAN[GG%10]); 
01C7:  MOVF   2C,W
01C8:  MOVWF  2E
01C9:  MOVLW  0A
01CA:  MOVWF  2F
01CB:  CALL   175
01CC:  MOVLW  22
01CD:  ADDWF  77,W
01CE:  MOVWF  04
01CF:  BCF    03.7
01D0:  MOVF   00,W
01D1:  MOVWF  2E
01D2:  MOVWF  2F
01D3:  CALL   19A
....................  
....................    OUTPUT_LOW(RCK); 
01D4:  BCF    2D.2
01D5:  MOVF   2D,W
01D6:  BSF    03.5
01D7:  MOVWF  07
01D8:  BCF    03.5
01D9:  BCF    07.2
....................    OUTPUT_HIGH(RCK); 
01DA:  BCF    2D.2
01DB:  MOVF   2D,W
01DC:  BSF    03.5
01DD:  MOVWF  07
01DE:  BCF    03.5
01DF:  BSF    07.2
....................    OUTPUT_LOW(G); 
01E0:  BCF    2D.3
01E1:  MOVF   2D,W
01E2:  BSF    03.5
01E3:  MOVWF  07
01E4:  BCF    03.5
01E5:  BCF    07.3
01E6:  RETURN
.................... } 
....................  
.................... void main() 
01E7:  MOVF   03,W
01E8:  ANDLW  1F
01E9:  MOVWF  03
01EA:  MOVLW  FF
01EB:  MOVWF  2D
01EC:  BSF    03.5
01ED:  BSF    03.6
01EE:  MOVF   09,W
01EF:  ANDLW  C0
01F0:  MOVWF  09
01F1:  BCF    03.6
01F2:  BCF    1F.4
01F3:  BCF    1F.5
01F4:  MOVLW  00
01F5:  BSF    03.6
01F6:  MOVWF  08
01F7:  BCF    03.5
01F8:  CLRF   07
01F9:  CLRF   08
01FA:  CLRF   09
01FB:  BCF    03.7
.................... { 
....................    SET_TRIS_D(0); 
*
0213:  MOVLW  00
0214:  BSF    03.5
0215:  MOVWF  08
....................    SET_TRIS_C(0); 
0216:  MOVWF  07
0217:  BCF    03.5
0218:  MOVWF  2D
....................    SET_TRIS_B(0); 
0219:  BSF    03.5
021A:  MOVWF  06
....................     
....................    lcd_init(); 
021B:  BCF    03.5
021C:  GOTO   097
....................    lcd_refresh(); 
021D:  GOTO   0D5
....................     
....................    KT: 
....................     
....................    lcd_gotoxy(1,1); 
021E:  MOVLW  01
021F:  MOVWF  32
0220:  MOVWF  33
0221:  CALL   0E1
....................    lcd_putc("RED LIGHT   "); 
0222:  MOVLW  04
0223:  BSF    03.6
0224:  MOVWF  0D
0225:  MOVLW  00
0226:  MOVWF  0F
0227:  BCF    03.6
0228:  CALL   11F
....................    lcd_gotoxy(1,2); 
0229:  MOVLW  01
022A:  MOVWF  32
022B:  MOVLW  02
022C:  MOVWF  33
022D:  CALL   0E1
....................    lcd_putc("STOP !!!   "); 
022E:  MOVLW  0B
022F:  BSF    03.6
0230:  MOVWF  0D
0231:  MOVLW  00
0232:  MOVWF  0F
0233:  BCF    03.6
0234:  CALL   11F
....................        
....................    OUTPUT_HIGH(D); 
0235:  BSF    03.5
0236:  BCF    06.0
0237:  BCF    03.5
0238:  BSF    06.0
....................    OUTPUT_LOW(X); 
0239:  BSF    03.5
023A:  BCF    06.1
023B:  BCF    03.5
023C:  BCF    06.1
....................    OUTPUT_LOW(V); 
023D:  BSF    03.5
023E:  BCF    06.2
023F:  BCF    03.5
0240:  BCF    06.2
....................     
....................    FOR(GG=22;GG>=0;GG--) 
0241:  MOVLW  16
0242:  MOVWF  2C
0243:  BTFSC  2C.7
0244:  GOTO   24F
....................    { 
....................       GIAIMA7DOAN(); 
0245:  CALL   1BA
....................       DELAY_MS(900); 
0246:  MOVLW  04
0247:  MOVWF  2E
0248:  MOVLW  E1
0249:  MOVWF  33
024A:  CALL   02A
024B:  DECFSZ 2E,F
024C:  GOTO   248
024D:  DECF   2C,F
024E:  GOTO   243
....................    } 
....................     
....................    OUTPUT_HIGH(X); 
024F:  BSF    03.5
0250:  BCF    06.1
0251:  BCF    03.5
0252:  BSF    06.1
....................    OUTPUT_LOW(D); 
0253:  BSF    03.5
0254:  BCF    06.0
0255:  BCF    03.5
0256:  BCF    06.0
....................    OUTPUT_LOW(V);     
0257:  BSF    03.5
0258:  BCF    06.2
0259:  BCF    03.5
025A:  BCF    06.2
....................        
....................    lcd_gotoxy(1,1); 
025B:  MOVLW  01
025C:  MOVWF  32
025D:  MOVWF  33
025E:  CALL   0E1
....................    lcd_putc("GREEN LIGHT  "); 
025F:  MOVLW  11
0260:  BSF    03.6
0261:  MOVWF  0D
0262:  MOVLW  00
0263:  MOVWF  0F
0264:  BCF    03.6
0265:  CALL   11F
....................    lcd_gotoxy(1,2); 
0266:  MOVLW  01
0267:  MOVWF  32
0268:  MOVLW  02
0269:  MOVWF  33
026A:  CALL   0E1
....................    lcd_putc("GO AHEAD  "); 
026B:  MOVLW  18
026C:  BSF    03.6
026D:  MOVWF  0D
026E:  MOVLW  00
026F:  MOVWF  0F
0270:  BCF    03.6
0271:  CALL   11F
....................     
....................    FOR(GG=15;GG>=0;GG--) 
0272:  MOVLW  0F
0273:  MOVWF  2C
0274:  BTFSC  2C.7
0275:  GOTO   280
....................    { 
....................       GIAIMA7DOAN(); 
0276:  CALL   1BA
....................       DELAY_MS(900); 
0277:  MOVLW  04
0278:  MOVWF  2E
0279:  MOVLW  E1
027A:  MOVWF  33
027B:  CALL   02A
027C:  DECFSZ 2E,F
027D:  GOTO   279
027E:  DECF   2C,F
027F:  GOTO   274
....................    } 
....................     
....................    OUTPUT_HIGH(v); 
0280:  BSF    03.5
0281:  BCF    06.2
0282:  BCF    03.5
0283:  BSF    06.2
....................    OUTPUT_LOW(D); 
0284:  BSF    03.5
0285:  BCF    06.0
0286:  BCF    03.5
0287:  BCF    06.0
....................    OUTPUT_LOW(X); 
0288:  BSF    03.5
0289:  BCF    06.1
028A:  BCF    03.5
028B:  BCF    06.1
....................        
....................        
....................    lcd_gotoxy(1,1); 
028C:  MOVLW  01
028D:  MOVWF  32
028E:  MOVWF  33
028F:  CALL   0E1
....................    lcd_putc("YELLOW LIGHT"); 
0290:  MOVLW  1E
0291:  BSF    03.6
0292:  MOVWF  0D
0293:  MOVLW  00
0294:  MOVWF  0F
0295:  BCF    03.6
0296:  CALL   11F
....................    lcd_gotoxy(1,2); 
0297:  MOVLW  01
0298:  MOVWF  32
0299:  MOVLW  02
029A:  MOVWF  33
029B:  CALL   0E1
....................    lcd_putc("SLOW DOWN"); 
029C:  MOVLW  25
029D:  BSF    03.6
029E:  MOVWF  0D
029F:  MOVLW  00
02A0:  MOVWF  0F
02A1:  BCF    03.6
02A2:  CALL   11F
....................        
....................    FOR(GG=5;GG>=0;GG--) 
02A3:  MOVLW  05
02A4:  MOVWF  2C
02A5:  BTFSC  2C.7
02A6:  GOTO   2B1
....................    { 
....................       GIAIMA7DOAN(); 
02A7:  CALL   1BA
....................       DELAY_MS(900); 
02A8:  MOVLW  04
02A9:  MOVWF  2E
02AA:  MOVLW  E1
02AB:  MOVWF  33
02AC:  CALL   02A
02AD:  DECFSZ 2E,F
02AE:  GOTO   2AA
02AF:  DECF   2C,F
02B0:  GOTO   2A5
....................    } 
....................    GOTO KT; 
02B1:  GOTO   21E
.................... } 
02B2:  SLEEP

Configuration Fuses:
   Word  1: 2CE2   HS NOWDT PUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
